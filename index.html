<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
   	<title>Predator and Prey Simulation - Progeny.js</title>
   	<!--<script src="rl.js"></script>
   	<script src="kdTree.js"></script>
   	<script src="linknodes.js"></script>
   	<script src="pipe.js"></script>
   	<script src="progeny.js"></script>
   	<script src="colormap.js"></script>-->
   	<script src="https://newsbubbles.github.io/progeny/rl.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/kdTree.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/linknodes.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/pipe.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/progeny.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/colormap.js"></script>
   	<style type="text/css">
   		body {
   			color: #FFDDDD;
   			background-color: #222;
   			margin: 0px;
   		}
   		canvas {
   			display: block;
   		}
   		.menu {
   			border-radius: 0.5em;
   			background-color: rgba(0, 0, 0, 0.65);
   			padding: 1em;
   			position: absolute;
   			bottom: 1em;
   			left: 1em;
   			width: 15em;
   		}
   		#cellprev {
   			width:20px;
   			height: 20px;
   			background-color: #222;
   			border: 1px solid #F00;
   			display: inline-block;
   		}
   		#cellname {
   			font-weight: bolder;
   			padding-left: 1em;
   			padding-right: 1em;
   		}
   		#cellstats {
   			padding-left: 50px;
   		}
   		#cellstats label {
   			font-weight: bold;
   		}
   	</style>
  </head>
  <body>
  	<canvas id="world"></canvas>
  	<div class="menu" id="menu"><span id="cellprev">&nbsp;</span> <span id="cellname"></span><div id="cellstats"></div></div>
  	<script type="text/javascript">
			const canvas = _.q('#world');
  		const ctx = canvas.getContext('2d');
  		const easeLoc = 0.002, easeVel = 0.005, minDist = 10, maxVel = 1.5;
  		const minRewardDist = 20, ratioPredator = 0.5;
  		const numPlayers = 30;
  		const continuousSpace = true;
  		const bouncyWalls = true;

  		//const deathAudio = new Audio('dead.wav');

  		function drawLine(x1, y1, x2, y2){
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.stroke();
				ctx.closePath();
  		}

  		window.selected = 0;
  		function selectCell(){
				window.world.cells.forEach(function(cell, index){
					if (index == window.selected){
						window.cell = cell;
					}
				});
				showCell(window.cell, window.selected);
  		}

  		function showCell(cell, index){
  			var e = _.q('#menu');
  			var ce = _.q('#cellprev');
  			var t = _.q('#cellname');
  			var s = _.q('#cellstats');
  			var strP = '';
 				ce.style.backgroundColor = colormap[index].hex;
  			if (isPredator(cell)){
  				ce.style.borderColor = '#f00';
  				strP = 'predator';
  			}else{
  				ce.style.borderColor = '#0f0';
  				strP = 'prey';
  			}
  			var cst = '';
  			for (k in cell.stats){
  				if (cell.stats.hasOwnProperty(k))
  					cst += '<div><label>' + k + '</label>: <span>' + cell.stats[k] + '</span></div>'
  			}
  			t.innerHTML = 'Agent ' + index + ' <i>(' + strP + ')</i>';
  			s.innerHTML = cst;
  		}

  		function isPredator(cell){
  			return cell.data[4] < ratioPredator;
  		}

  		window.clipcell = function(cell){
  			// location clipping
  			if (continuousSpace){
	  			if (cell.data[0] < 0) cell.data[0] += canvas.width;
	  			if (cell.data[1] < 0) cell.data[1] += canvas.height;
	  			if (cell.data[0] > canvas.width) cell.data[0] = 0;
	  			if (cell.data[1] > canvas.height) cell.data[1] = 0;
	  		}else{
	  			var clipped = false, clx = false, cly = false;
	  			if (cell.data[0] < 0){ cell.data[0] = 0; clipped = true; clx = true;}
	  			if (cell.data[1] < 0){ cell.data[1] = 0; clipped = true; cly = true;}
	  			if (cell.data[0] > canvas.width){ cell.data[0] = canvas.width; clipped = true; clx = true;}
	  			if (cell.data[1] > canvas.height){ cell.data[1] = canvas.height; clipped = true; cly = true;}
	  			// if hit a border, stop velocity or 
	  			if (clipped){
	  				if (bouncyWalls){
	  					if (clx) cell.data[2] = -cell.data[2];
	  					if (cly) cell.data[3] = -cell.data[3];
	  				}else{
	  					cell.data[2] = 0;
	  					cell.data[3] = 0;
	  				}
	  			}
	  		}
	  		// velocity clipping
  			if (cell.data[2] > maxVel) cell.data[2] = maxVel;
  			if (cell.data[2] < -maxVel) cell.data[2] = -maxVel;
  			if (cell.data[3] > maxVel) cell.data[3] = maxVel;
  			if (cell.data[3] < -maxVel) cell.data[3] = -maxVel;
  		};
  		function locDiff(v1, v2){
  			return [v2[0] - v1[0], v2[1] - v1[1]];
  		}
  		function dist(v1, v2){
  			var d = locDiff(v1, v2);
  			return Math.sqrt(Math.abs(d[0] * d[0] + d[1] * d[1]));
  		}
  		function velDiff(v1, v2){
  			return [v2[2] - v1[2], v2[3] - v1[3]];
  		}
  		function vecMult(v, m){
  			return [v[0] * m, v[1] * m];
  		}

  		// Load World and visualize it in the Canvas
  		window.addEventListener('load', function(e){
  			//make sure canvas resizes

  			function resizeCanvas(e){
  				var el = canvas;
  				el.width = window.innerWidth;
  				el.height = window.innerHeight;
  			}
  			window.addEventListener('resize', resizeCanvas);
  			resizeCanvas(null);
  			window.addEventListener('keydown', function(e){
  				var k = e.keyCode;
  				if (k == 39 || k == 40) window.selected += 1;
  				if (k == 37 || k == 38) window.selected -= 1;
  				if (window.selected < 0) window.selected = numPlayers - 1;
  				if (window.selected >= numPlayers) window.selected = 0;
  				selectCell();
  			});
  			_.q('#cellprev').addEventListener('click', function(e){
  				window.selected += 1;
  				if (window.selected >= numPlayers) window.selected = 0;
  				selectCell();
  			});

  			//pipe = new Pipe()
			//console.log(pipe.steps)
			/*
				ideas to try:
					create attacking or sharing
					create an "energy" metric
						that is spent for movement
						that is restored when prey is "together"
						or when predators eat
						allow predators to die and respawn
					make velocity use energy as a lowbounded multiplier
			*/

  			var conf = {
  				numCells: numPlayers,
  				dataWidth: 6,
  				maxNeighbors: 4,
  				neighborDistance: 600,
  				dimTitles: ['x', 'y', 'vx', 'vy', 'type', 'life', 'energy', 'attack', 'share', 'f', 'g'],
  				initDimRange: [canvas.width, canvas.height, 0, 0, 1, 1, 1, 1, 1, 180],
  				initValues: [null, null, null, null, null, 1, 1],
  				dimTreeIndices: [0, 1, 2, 3],
  				stats: {
  					'deaths': 0,
  					'kills': 0,
  					'score': 0,
  				},
  				init: function(world){
  					world.cells.forEach(function(cell, index){
	  					var predator = cell.data[4] < ratioPredator;
	  					//if (predator){
	  					//	cell.maxNeighbors = 3;
	  					//}
  					});
  				},
  				actions: [	/* This defines the action space the DQN chooses from */
					function(cell, neighbor){
						//Do Nothing...
					},
					function(cell, neighbor){
						//Move toward neighbor
						d = locDiff(cell.data, neighbor);
						e = vecMult(d, easeLoc);
						cell.agg(2, e[0]);
						cell.agg(3, e[1]);
					},
					function(cell, neighbor){
						//Move away from neighbor
						d = locDiff(cell.data, neighbor);
						e = vecMult(d, easeLoc);
						cell.agg(2, -e[0]);
						cell.agg(3, -e[1]);
					},
					function(cell, neighbor){
						//Move in same direction as neighbor
						d = velDiff(cell.data, neighbor);
						e = vecMult(d, easeVel);
						cell.agg(2, e[0]);
						cell.agg(3, e[1]);
					},
					function(cell, neighbor){
						//Move in opposite direction
						d = velDiff(cell.data, neighbor);
						e = vecMult(d, easeVel);
						cell.agg(2, -e[0]);
						cell.agg(3, -e[1]);
					},
					/* Non-relative movement */
					function(cell, neighbor){
						//Move up
						d = velDiff(cell.data, [0, 0, 0, -maxVel]);
						e = vecMult(d, easeLoc);
						cell.agg(2, e[0]);
						cell.agg(3, e[1]);
					},
					function(cell, neighbor){
						//Move down
						d = velDiff(cell.data, [0, 0, 0, +maxVel]);
						e = vecMult(d, easeLoc);
						cell.agg(2, e[0]);
						cell.agg(3, e[1]);
					},
					function(cell, neighbor){
						//Move left
						d = velDiff(cell.data, [0, 0, -maxVel, 0]);
						e = vecMult(d, easeLoc);
						cell.agg(2, e[0]);
						cell.agg(3, e[1]);
					},
					function(cell, neighbor){
						//Move right
						d = velDiff(cell.data, [0, 0, +maxVel, 0]);
						e = vecMult(d, easeLoc);
						cell.agg(2, e[0]);
						cell.agg(3, e[1]);
					},
				],
				cellStep: function(cell){
					// This happens after cell walks through neighbors

					//use the data[2] and data[3] as velocity vector for data[0] and data[1]
					cell.agg(0, cell.data[2]);
					cell.agg(1, cell.data[3]);
					//cell.data[3] += 0.1;
					window.clipcell(cell);
				},
				cellReward: function(cell, neighbor){
					// Find 2D distance from neighbor (first two dimensions)
					d = dist(cell.data, neighbor);
					// Figure out what "team" cell is on and what neighbor is.
					var cp = cell.data[4] < ratioPredator, 
						np = neighbor[4] < ratioPredator;
					var chase = cp && !np, 
						run = !cp && np, 
						team = cp && np || !cp && !np;
					//console.log(d, minDist);
					if (d > 0 && d < minDist){
						// If the cell is "hit"
						//console.log('hit', run, chase, team);
						if (run){
							// If Prey, lose life, or die if life is < 0
							cell.data[5] -= 0.1;
							console.log('hit');
							if (cell.data[5] <= 0.0){ // DIE FOOL!
								cell.data[0] = Math.random() * canvas.width;
								cell.data[1] = Math.random() * canvas.height;
								cell.data[2] = 0;
								cell.data[3] = 0;
								cell.data[5] = 1.0;
								cell.count('deaths');
								cell.count('score', -100);
								return -100.0;
							}
						}
						if (chase){
							// give a big reward if cell is predator and prey is dead (eaten)
							if (neighbor[5] <= 0.1){
								console.log('KILL!');
								cell.count('kills');
								cell.count('score', 100);
								return 100.0;
							}
						}
						if (team && !cp){
							cell.data[5] += 0.025;
							if (cell.data[5] > 1) cell.data[5] = 1;
						}
						points = chase ? 1.0: run ? -2.0: team && !cp ? 2.0: 0.0;
						cell.count('score', points);
						return points;
					}
					if (team && !cp && d < minRewardDist && d > 0){
						cell.count('score');
						return 1.0;
					}
				},
				interval: 0,
  			draw: function(world){
					ctx.clearRect(0, 0, canvas.width, canvas.height);
  					world.cells.forEach(function(cell, index){
  						var predator = cell.data[4] < ratioPredator;
  						var x = Math.round(cell.data[0]);
  						var y = Math.round(cell.data[1]);
  						var r = (predator ? 8: 5);
  						var rr = r * 2;
  						var ir = r * cell.data[5], irr = rr * cell.data[5];
  						if (index == window.selected){
	  						ctx.strokeStyle = '#999';
	  						ctx.lineWidth = 0.5;
	  						drawLine(x, 0, x, canvas.height);
	  						drawLine(0, y, canvas.width, y);
	  						ctx.strokeStyle = '#ddd';
	  						for (var nn = 0; nn < cell.neighbors.length; nn++){
	  							var nv = cell.neighbors[nn];
	  							drawLine(x, y, nv[0].x, nv[0].y);
	  						}
	  					}
  						ctx.fillStyle = window.colormap[index].hex;
  						ctx.strokeStyle = predator ? '#f00': '#0f0';
  						ctx.fillRect(x - ir, y - ir, irr, irr);
  						ctx.lineWidth = 1;
  						ctx.beginPath();
  						ctx.rect(x - r, y - r, rr, rr);
  						ctx.stroke();
  					});
  				},
  			};

  			// Create world from configuration
  			window.world = new World(conf);

  			// Create the cells in the world
  			window.world.generate();
  			console.log(world.cells.origNode);
  			
  			// Start the world, to stop use world.stop()
  			world.start();

	  		selectCell();

  		});
  	</script>
  </body>
</html>
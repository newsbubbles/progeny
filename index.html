<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
   	<title>Progeny: Communicative CA</title>
   	<script src="https://newsbubbles.github.io/progeny/rl.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/kdTree.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/linknodes.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/pipe.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/progeny.js"></script>
   	<script src="https://newsbubbles.github.io/progeny/colormap.js"></script>
   	<style type="text/css">
   		body {
   			background-color: #222;
   			margin: 0px;
   		}
   	</style>
  </head>
  <body>
  	<canvas id="world"></canvas>
  	<script type="text/javascript">
		const canvas = _.q('#world');
  		const ctx = canvas.getContext('2d');
  		const easeLoc = 0.002, easeVel = 0.03, minDist = 10, maxVel = 1.5;
  		const minRewardDist = 20, ratioPredator = 0.1;
  		//const deathAudio = new Audio('dead.wav');
  		const continuousSpace = false;
  		const bouncyWalls = true;

  		window.clipcell = function(cell){
  			// location clipping
  			if (continuousSpace){
	  			if (cell.data[0] < 0) cell.data[0] += canvas.width;
	  			if (cell.data[1] < 0) cell.data[1] += canvas.height;
	  			if (cell.data[0] > canvas.width) cell.data[0] = 0;
	  			if (cell.data[1] > canvas.height) cell.data[1] = 0;
	  		}else{
	  			var clipped = false, clx = false, cly = false;
	  			if (cell.data[0] < 0){ cell.data[0] = 0; clipped = true; clx = true;}
	  			if (cell.data[1] < 0){ cell.data[1] = 0; clipped = true; cly = true;}
	  			if (cell.data[0] > canvas.width){ cell.data[0] = canvas.width; clipped = true; clx = true;}
	  			if (cell.data[1] > canvas.height){ cell.data[1] = canvas.height; clipped = true; cly = true;}
	  			// if hit a border, stop velocity or 
	  			if (clipped){
	  				if (bouncyWalls){
	  					if (clx) cell.data[2] = -cell.data[2];
	  					if (cly) cell.data[3] = -cell.data[3];
	  				}else{
	  					cell.data[2] = 0;
	  					cell.data[3] = 0;
	  				}
	  			}
	  		}
	  		// velocity clipping
  			if (cell.data[2] > maxVel) cell.data[2] = maxVel;
  			if (cell.data[2] < -maxVel) cell.data[2] = -maxVel;
  			if (cell.data[3] > maxVel) cell.data[3] = maxVel;
  			if (cell.data[3] < -maxVel) cell.data[3] = -maxVel;
  		};
  		function locDiff(v1, v2){
  			return [v2[0] - v1[0], v2[1] - v1[1]];
  		}
  		function dist(v1, v2){
  			var d = locDiff(v1, v2);
  			return Math.sqrt(Math.abs(d[0] * d[0] + d[1] * d[1]));
  		}
  		function velDiff(v1, v2){
  			return [v2[2] - v1[2], v2[3] - v1[3]];
  		}
  		function vecMult(v, m){
  			return [v[0] * m, v[1] * m];
  		}

  		// Load World and visualize it in the Canvas
  		window.addEventListener('load', function(e){
  			//make sure canvas resizes

  			function resizeCanvas(e){
  				var el = canvas;
  				el.width = window.innerWidth;
  				el.height = window.innerHeight;
  			}
  			window.addEventListener('resize', resizeCanvas);
  			resizeCanvas(null);

  			//pipe = new Pipe()
			//console.log(pipe.steps)
			/*
				ideas to try:
					create attacking or sharing
					create an "energy" metric
						that is spent for movement
						that is restored when prey is "together"
						or when predators eat
						allow predators to die and respawn
					make velocity use energy as a lowbounded multiplier
			*/

  			var conf = {
  				numCells: 30,
  				dataWidth: 6,
  				maxNeighbors: 3,
  				neighborDistance: 500,
  				dimTitles: ['x', 'y', 'vx', 'vy', 'type', 'life', 'energy', 'attack', 'share', 'f', 'g'],
  				initDimRange: [canvas.width, canvas.height, 0, 0, 1, 1, 1, 1, 1, 180],
  				initValues: [null, null, null, null, null, 1, 1],
  				stats: {
  					'deaths': 0,
  					'kills': 0,
  					'score': 0,
  				},
  				init: function(world){

  				},
  				actions: [	/* This defines the action space the DQN chooses from */
					function(cell, neighbor){
						//Do Nothing...
					},
					function(cell, neighbor){
						//Move toward neighbor
						d = locDiff(cell.data, neighbor[0]);
						e = vecMult(d, easeLoc);
						cell.data[2] += e[0];
						cell.data[3] += e[1];
					},
					function(cell, neighbor){
						//Move away from neighbor
						d = locDiff(cell.data, neighbor[0]);
						e = vecMult(d, easeLoc);
						cell.data[2] -= e[0];
						cell.data[3] -= e[1];
					},
					function(cell, neighbor){
						//Move in same direction as neighbor
						d = velDiff(cell.data, neighbor[0]);
						e = vecMult(d, easeVel);
						cell.data[2] += e[0];
						cell.data[3] += e[1];
					},
					function(cell, neighbor){
						//Move in opposite direction
						d = velDiff(cell.data, neighbor[0]);
						e = vecMult(d, easeVel);
						cell.data[2] -= e[0];
						cell.data[3] -= e[1];
					},
					/* Non-relative movement */
					function(cell, neighbor){
						//Move up
						d = velDiff(cell.data, [0, 0, 0, -maxVel]);
						e = vecMult(d, easeLoc);
						cell.data[2] += e[0];
						cell.data[3] += e[1];
					},
					function(cell, neighbor){
						//Move down
						d = velDiff(cell.data, [0, 0, 0, +maxVel]);
						e = vecMult(d, easeLoc);
						cell.data[2] += e[0];
						cell.data[3] += e[1];
					},
					function(cell, neighbor){
						//Move left
						d = velDiff(cell.data, [0, 0, -maxVel, 0]);
						e = vecMult(d, easeLoc);
						cell.data[2] += e[0];
						cell.data[3] += e[1];
					},
					function(cell, neighbor){
						//Move right
						d = velDiff(cell.data, [0, 0, +maxVel, 0]);
						e = vecMult(d, easeLoc);
						cell.data[2] += e[0];
						cell.data[3] += e[1];
					},
				],
				cellStep: function(cell){
					// This happens after cell walks through neighbors

					//use the data[2] and data[3] as velocity vector for data[0] and data[1]
					cell.data[0] += cell.data[2];
					cell.data[1] += cell.data[3];
					//cell.data[3] += 0.1;
					window.clipcell(cell);
				},
				cellReward: function(cell, neighbor){
					// Find 2D distance from neighbor (first two dimensions)
					d = dist(cell.data, neighbor[0]);
					// Figure out what "team" cell is on and what neighbor is.
					var cp = cell.data[4] < ratioPredator, 
						np = neighbor[0][4] < ratioPredator;
					var chase = cp && !np, 
						run = !cp && np, 
						team = cp && np || !cp && !np;
					//console.log(d, minDist);
					if (d > 0 && d < minDist){
						// If the cell is "hit"
						//console.log('hit', run, chase, team);
						if (run){
							// If Prey, lose life, or die if life is < 0
							cell.data[5] -= 0.1;
							console.log('hit');
							if (cell.data[5] <= 0.0){ // DIE FOOL!
								cell.data[0] = Math.random() * canvas.width;
								cell.data[1] = Math.random() * canvas.height;
								cell.data[2] = 0;
								cell.data[3] = 0;
								cell.data[5] = 1.0;
								cell.count('deaths');
								cell.count('score', -100);
								return -100.0;
							}
						}
						if (chase){
							// give a big reward if cell is predator and prey is dead (eaten)
							if (neighbor[0][5] <= 0.1){
								console.log('KILL!');
								cell.count('kills');
								cell.count('score', 100);
								return 100.0;
							}
						}
						points = chase ? 1.0: run ? -2.0: team && !cp ? 1.0: 0.0;
						cell.count('score', points);
						return points;
					}
					if (team && !cp && d < minRewardDist && d > 0){
						cell.count('score');
						return 1.0;
					}
				},
				interval: 0,
  				draw: function(world){
					//ctx.clearRect(0, 0, canvas.width, canvas.height);
  					world.cells.forEach(function(cell, index){
  						var predator = cell.data[4] < ratioPredator;
  						var x = Math.round(cell.data[0]);
  						var y = Math.round(cell.data[1]);
  						var r = (predator ? 8: 5);
  						var rr = r * 2;
  						var ir = r * cell.data[5], irr = rr * cell.data[5];
  						ctx.fillStyle = window.colormap[index].hex;
  						ctx.strokeStyle = predator ? '#f00': '#0f0';
  						/*if (cell.neighbors.length > 0){
	  						var n = cell.neighbors[0][0];
	  						var xn = Math.round(n[0]);
	  						var yn = Math.round(n[1]);
	  						ctx.strokeStyle = ctx.fillStyle;
	  						ctx.beginPath();
	  						ctx.moveTo(x, y);
	  						ctx.lineTo(xn, yn);
	  						ctx.stroke();
	  						ctx.closePath();
	  					}*/
  						ctx.fillRect(x - ir, y - ir, irr, irr);
  						ctx.lineWidth = 1;
  						ctx.beginPath();
  						ctx.rect(x - r, y - r, rr, rr);
  						ctx.stroke();
  					});
  				},
  			};

  			// Create world from configuration
  			window.world = new World(conf);

  			// Create the cells in the world
  			window.world.generate();
  			console.log(world.cells.origNode);
  			
  			// Start the world, to stop use world.stop()
  			world.start();

  		});
  	</script>
  </body>
</html>